function e(){return e=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(e[r]=s[r])}return e},e.apply(this,arguments)}const t="diagnosticTest",s="finalTests",r="customTests",o="practiceTests",n="review",a="branchTest",i="learn",c={1:o,3:s,4:a,5:r,6:t},d={practiceTests:1,finalTests:2,branchTest:4,customTests:5,diagnosticTest:6,review:7,learn:8},l={learn:0,practiceTests:1,finalTests:9,diagnosticTest:10,customTests:3,branchTest:12,review:13};const p=async({TopicProgress:t,topicsStore:s})=>{if(t.length)try{await Promise.all(t.map((async t=>{const r=e({},s.get(t.topicId),{status:1===(null==t?void 0:t.progress)?1:0});await s.put(r)})))}catch(e){console.log("üöÄ ~ convertTopicsFromServer ~ err:",e)}},u=async({QuestionProgress:e,userActionsStore:t})=>{(null==e?void 0:e.length)&&await Promise.all(e.map((async e=>{const s=[];1===e.like&&s.push("like"),-1===e.like&&s.push("dislike"),e.bookmark&&s.push("save");const r={userId:-1,id:e.questionId,questionId:e.questionId,actions:s};await t.put(r)})))},g=async({TestInfo:e,UserTestData:t,testQuestionsStore:s,topicsStore:r})=>{const o=(e.length>0?t.filter((t=>e.some((e=>e.testId!==t.testId)))):t).map((e=>new Promise(((t,r)=>{const o=s.get(e.testId);o.onsuccess=()=>{const n=o.result;if(n){n.status=3===e.status?1:0;const o=s.put(n);o.onsuccess=()=>t(),o.onerror=()=>r(o.error)}else t()},o.onerror=()=>r(o.error)}))));await Promise.all(o);const n=e.map(((e,o)=>new Promise((async(n,a)=>{try{const{testId:i,testQuestionNum:d,passPercent:l,type:p,testQuestionData:u,timeTest:g,testSettingId:y}=e,m=JSON.parse(u)||[],f=t.find((t=>t.testId===e.testId)),I=m.map((e=>Number(e.topicId))),h=I.map((e=>new Promise(((t,s)=>{const o=r.get(e);o.onsuccess=()=>t(o.result),o.onerror=()=>s(o.error)})))),w=(await Promise.all(h)).filter((e=>void 0!==e)),S=m.map((e=>{var t;return{topicId:Number(e.topicId),questionIds:e.questionIds.map((e=>Number(e))),totalQuestion:e.questionIds.length,topicName:null==(t=w.find((t=>t.id===Number(e.topicId))))?void 0:t.name}})),T={id:i,index:o,totalDuration:g/60,isGamePaused:!1,startTime:0,elapsedTime:0,gameMode:c[p],passingThreshold:l,totalQuestion:Number(d),status:f&&3===f.status?1:0,attemptNumber:1,topicIds:I,groupExamData:S,gameDifficultyLevel:1===y?"newbie":2===y?"expert":"newbie",createDate:(new Date).getTime(),sync:1},b=s.put(T);b.onsuccess=()=>n(),b.onerror=()=>a(b.error)}catch(e){a(e)}}))));await Promise.all(n)},y=({objectStore:e,keys:t})=>new Promise(((s,r)=>{if(t&&t.length>0)Promise.all(t.map((t=>new Promise(((s,r)=>{const o=e.get(t);o.onsuccess=()=>s(o.result),o.onerror=()=>r(o.error)}))))).then((e=>s(e.filter((e=>void 0!==e))))).catch(r);else{const t=e.getAll();t.onsuccess=()=>s(t.result),t.onerror=()=>r(t.error)}})),m=async({UserQuestionProgress:c,questionsStore:d,topicsStore:p,userProgressStore:u})=>{const g=c.map((e=>e.questionId)),[m,I]=await Promise.all([y({keys:g,objectStore:d}),y({keys:g,objectStore:p})]),h=c.reduce(((c,d)=>{const p=d.questionId;if(c[p]||(c[p]=[]),c[p].length>0){const n=c[p][0],u=m.find((e=>d.questionId===e.id)),g=((null==d?void 0:d.choicesSelected)||[]).map((n=>{const c=null==u?void 0:u.answers.find((e=>e.id===n));return c?e({},c,{turn:1,type:d.type===l.learn?i:d.type===l.practiceTests?o:d.type===l.finalTests?s:d.type===l.diagnosticTest?t:d.type===l.customTests?r:d.type===l.branchTest?a:i,parentId:null==d?void 0:d.testIdOrTopicId}):null})).filter((e=>null!==e)),y=e({},n,{selectedAnswers:[...n.selectedAnswers,...g]||[]});c[p]=[y]}else{const u=m.find((e=>d.questionId===e.id)),g=(d.choicesSelected||[]).map((c=>{const p=null==u?void 0:u.answers.find((e=>e.id===c));return p?e({},p,{turn:1,parentId:null==d?void 0:d.testIdOrTopicId,type:d.type===l.learn?i:d.type===l.practiceTests?o:d.type===l.finalTests?s:d.type===l.diagnosticTest?t:d.type===l.customTests?r:d.type===l.branchTest?a:n,isSynced:!0}):null})).filter((e=>null!==e)),y={id:d.questionId,parentId:(null==u?void 0:u.partId)||-1,level:(null==u?void 0:u.level)||-1,selectedAnswers:g||[],isSynced:!0};c[p].push(y)}return c}),{}),w=Object.values(h).flat(),S=new Map(I.map((e=>[e.id,e])));for(const e of w){const t=S.get(e.id);t?(t.selectedAnswers=f({oldAnswers:t.selectedAnswers,newAnswers:e.selectedAnswers}),S.set(e.id,t)):S.set(e.id,e)}const T=Array.from(S.values());await((e,t)=>new Promise(((s,r)=>{const o=e.map((e=>new Promise(((s,r)=>{const o=t.put(e);o.onsuccess=()=>s(),o.onerror=()=>r(o.error)}))));Promise.all(o)})))(T,u)},f=({oldAnswers:t=[],newAnswers:s=[]})=>{const r=[...t];for(const t of s){const s=r.findIndex((e=>e.id===t.id));s>=0?r[s]=e({},r[s],t):r.push(t)}return r},I=async({topics:t,topicsStore:s})=>{if(!t)return[];const r=t.filter((e=>1===e.type)),o=t.filter((e=>2===e.type)),n=t.filter((e=>1===e.status&&3===e.type)),a=n.filter((e=>!e.isSynced)),i=a.map((e=>({key:e.id,changes:{isSynced:!0}})));await new Promise(((t,r)=>{let o=0;0!==i.length?i.forEach((({key:n,changes:a})=>{const c=s.get(n);c.onsuccess=()=>{const n=c.result;if(n){const c=e({},n,a),d=s.put(c);d.onsuccess=()=>{o++,o===i.length&&t()},d.onerror=()=>r(d.error)}else o++,o===i.length&&t()},c.onerror=()=>r(c.error)})):t()}));const c=a.map((e=>({topicId:e.id,passed:1,lock:0,progress:1,lastUpdate:Date.now(),type:e.type,parentId:e.parentId}))),d=o.filter((e=>n.some((t=>t.parentId===e.id)))).map((e=>{const s=n.filter((t=>t.parentId===e.id)),r=t.filter((t=>t.parentId===e.id&&3===t.type)).length||1,o=s.length/r;return{topicId:e.id,passed:1===o?1:0,lock:0,progress:o,type:e.type,lastUpdate:Date.now(),parentId:e.parentId}})),l=r.filter((e=>d.some((t=>t.parentId===e.id)))).map((e=>{const s=t.find((t=>t.id===e.id)),r=t.filter((e=>e.parentId===(null==s?void 0:s.id))).map((e=>e.id)),o=t.filter((e=>r.includes(e.id))),n=o.filter((e=>1===e.status)),a=o.length?n.length/o.length:0;return{topicId:e.id,passed:1===a?1:0,lock:0,progress:a,lastUpdate:Date.now()}}));return[...c,...d,...l]},h=async({userActionStore:e,reactions:t})=>{const s=(null==t?void 0:t.filter((e=>!e.isSynced)))||[],r=s.map((e=>({bookmark:e.actions.includes("save"),questionId:e.questionId,like:e.actions.includes("dislike")?-1:e.actions.includes("like")?1:0,lastUpdate:Date.now(),status:1})));return s.length>0&&await new Promise(((t,r)=>{let o=0;s.forEach((n=>{const a=e.get(n.questionId);a.onsuccess=()=>{const n=a.result;if(n){n.isSynced=!0;const a=e.put(n);a.onsuccess=()=>{o++,o===s.length&&t()},a.onerror=()=>r(a.error)}else o++,o===s.length&&t()},a.onerror=()=>r(a.error)}))})),r},w=({progress:e,tests:t})=>{const s=e||[];return(t||[]).filter((e=>s.some((t=>t.selectedAnswers.some((t=>t.parentId===e.id)))))).map((e=>{const t=s.filter((t=>t.selectedAnswers.some((t=>t.correct&&t.parentId===e.id)))).length;return{testId:e.id,testSettingId:"newbie"===e.gameDifficultyLevel?1:"expert"===e.gameDifficultyLevel?2:3,lock:0,lastUpdate:Date.now(),status:1===e.status?3:t>0?1:2,totalQuestion:e.totalQuestion,correctNumber:t}}))},S=({appId:t,progress:s,questions:r,tests:o,uniqueParentIdList:n,userId:a})=>{const i=null==o?void 0:o.filter((e=>("customTests"===e.gameMode||"diagnosticTest"===e.gameMode)&&(null==n?void 0:n.includes(e.id))));if(!i||0===i.length)return[];const c=i.map((r=>{const o=null==s?void 0:s.filter((e=>e.selectedAnswers.some((e=>e.parentId===r.id)))).map((t=>e({},t,{selectedAnswers:t.selectedAnswers.filter((e=>e.parentId===r.id))}))),n=(null==o?void 0:o.reduce(((e,t)=>e+t.selectedAnswers.filter((e=>e.correct)).length),0))||0;return{testId:r.id,shortId:r.id,testSettingId:"newbie"===r.gameDifficultyLevel?1:"expert"===r.gameDifficultyLevel?2:3,status:"customTests"===r.gameMode?r.status:1,totalQuestion:r.totalQuestion,correctNumber:n,type:d[r.gameMode],testQuestionData:JSON.stringify(r.groupExamData),lastUpdate:Date.now(),userId:a,appId:t}}));return console.log("üöÄ ~ syncTests:",c),c},T=async({questions:t,userProgressStore:s})=>{if(!t)return[];const r=t.reduce(((e,t)=>(t.selectedAnswers.forEach((s=>{const r=`${t.id}-${s.parentId}-${l[s.type]}`;e[r]||(e[r]={histories:[],questionId:t.id,playedTimes:[],type:l[s.type],playing:0,lastUpdate:Date.now(),parentId:s.parentId,choicesSelected:[],testIdOrTopicId:s.parentId}),e[r].histories.push(s.correct?1:0),e[r].choicesSelected.includes(s.id)||e[r].choicesSelected.push(s.id),e[r].playedTimes.push({startTime:s.startAt,endTime:s.endAt})})),e)),{}),o=Object.values(r).map((t=>e({},t,{playedTimes:JSON.stringify(t.playedTimes)}))),n=t.map((e=>({key:e.id,changes:{isSynced:!0}})));return await new Promise(((e,t)=>{let r=0;0!==n.length?n.forEach((o=>{const a=s.get(o.key);a.onsuccess=()=>{const o=a.result;if(o){o.isSynced=!0;const a=s.put(o);a.onsuccess=()=>{r++,r===n.length&&e()},a.onerror=()=>t(a.error)}else r++,r===n.length&&e()},a.onerror=()=>t(a.error)})):e()})),o},b=async({syncKey:e,appId:t,userId:s,db:r})=>{try{const o=function(){const e=new Date,t=new Date(e.getFullYear(),e.getMonth(),e.getDate(),0,0,0,0);return t.setDate(t.getDate()-1),t.getTime()}(),n={appId:t,userId:s,deleteOldData:!1,user_data:{userId:s,syncKey:e,appId:t,mapUpdateData:{QuestionProgress:o,UserQuestionProgress:o,TestInfo:o,UserTestData:o,TopicProgress:o}}},a=await fetch("https://micro-enigma-235001.appspot.com/api/app/flutter?type=get-user-data",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(n)});if(!a.ok)throw new Error(`Server tr·∫£ v·ªÅ m√£ l·ªói: ${a.status}`);const i=await a.json(),{UserQuestionProgress:c,TestInfo:d,QuestionProgress:l,TopicProgress:y,UserTestData:f}=i,I=r.transaction(["passingApp","testQuestions","topics","questions","useActions","userProgress"],"readwrite"),h=I.objectStore("topics"),w=I.objectStore("useActions"),S=I.objectStore("testQuestions"),T=I.objectStore("questions"),b=I.objectStore("userProgress");await Promise.all([p({TopicProgress:y,topicsStore:h}),u({QuestionProgress:l,userActionsStore:w}),g({TestInfo:d,UserTestData:f,testQuestionsStore:S,topicsStore:h}),m({UserQuestionProgress:c,questionsStore:T,topicsStore:h,userProgressStore:b})])}catch(e){throw console.error("syncDown error:",e),e}};self.addEventListener("install",(e=>{console.log("Service Worker installed.",e)})),self.addEventListener("activate",(e=>{console.log("Service Worker activated.",e)}));let P;self.addEventListener("message",(async t=>{if("INIT_DB"===t.data.type&&(P=await(async({dbName:t,dbVersion:s})=>new Promise(((r,o)=>{const n=indexedDB.open(t,s);n.onerror=()=>{console.error("Error opening IndexedDB in SW:",n.error),o(n.error)},n.onsuccess=async t=>{const s=t.target.result,o=s.transaction("passingApp","readonly").objectStore("passingApp").count();o.onsuccess=async()=>{if(o.result>0)console.log("Data already exists in IndexedDB, skipping fetch API.");else try{const[t,r,o]=await Promise.all([fetch("/api/sw/passing").then((e=>e.json())),fetch("/api/sw/tests").then((e=>e.json())),fetch("/api/sw/topics").then((e=>e.json()))]),n=()=>{const e=new Date;return`WEB-${e.getFullYear()}${String(e.getMonth()+1).padStart(2,"0")}${String(e.getDate()).padStart(2,"0")}-${String(e.getMinutes()).padStart(2,"0")}`},a=t.totalQuestion,i=200,c=Math.ceil(a/i),d=await Promise.all(Array.from({length:c},((e,t)=>fetch(`/api/sw/question/${t}`).then((e=>e.json()))))),l=s.transaction(["passingApp","testQuestions","topics","questions"],"readwrite");l.objectStore("passingApp").put(e({},t,{syncKey:n()}));const p=l.objectStore("testQuestions");Array.isArray(r)?r.forEach((e=>p.put(e))):p.put(r);const u=l.objectStore("topics");Array.isArray(o)?o.forEach((e=>u.put(e))):u.put(o);const g=l.objectStore("questions");d.forEach((e=>{Array.isArray(e)?e.forEach((e=>g.put(e))):g.put(e)})),l.oncomplete=()=>{console.log("All data has been saved to IndexedDB successfully.")},l.onerror=e=>{const t=e.target;console.error("Error counting data in the passingApp table:",t.error)}}catch(e){console.error("Error fetching data:",e)}r(s)}}})))({dbName:"asvab",dbVersion:1}),t.ports[0].postMessage({status:"success",message:"DB initialized and data fetched (if not already present)."})),"SYNC_UP"===t.data.type){const{syncKey:e,appId:s,userId:r}=t.data.payload;await(async({syncKey:e,appId:t,userId:s,db:r})=>{try{const o=r.transaction(["passingApp","testQuestions","topics","questions","useActions","userProgress"],"readwrite"),n=o.objectStore("useActions"),a=o.objectStore("topics"),i=o.objectStore("testQuestions"),c=o.objectStore("questions"),d=o.objectStore("userProgress"),[l,p,u,g]=await Promise.all([y({objectStore:i}),y({objectStore:n}),y({objectStore:d}),y({objectStore:a})]),m=(null==u?void 0:u.map((e=>e.id)))||[],f=await y({objectStore:c,keys:m}),b=[...u||[]].map((e=>e.selectedAnswers.map((e=>e.parentId)))).flat(),P=[...new Set(b)],v=null==u?void 0:u.filter((e=>!e.isSynced));console.log("üöÄ ~ listNotSync:",v);const[A,D,j,q,Q]=await Promise.all([I({topics:g,topicsStore:a}),h({userActionStore:n,reactions:p}),w({tests:l,progress:u}),S({appId:t,progress:u,questions:f,tests:l,uniqueParentIdList:P,userId:s}),T({questions:v,userProgressStore:d})]),k={appId:t,fixed:!0,userId:s,user_data:{NewDailyGoal:[],NewStudyPlan:[],TestInfo:q,UserTestData:j,QuestionProgress:D,TopicProgress:A,UserQuestionProgress:Q,SyncKey:[e]}},N=await fetch("https://micro-enigma-235001.appspot.com/api/app/flutter?type=set-user-data",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(k)}),U=await N.json();console.log("üöÄ ~ data:",U)}catch(e){console.log("üöÄ ~ err:",e)}})({syncKey:e,appId:s,userId:r,db:P})}if("SYNC_DOWN"===t.data.type){const{syncKey:e,appId:s,userId:r}=t.data.payload;await b({syncKey:e,appId:s,userId:r,db:P})}}));
